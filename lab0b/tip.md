Здесь список подсказок

Ошибки которые надо исправить:

- [x] обработка исключения открытия файла в классе Reader
- [x] убрать лишние this
- [x] ответить на: *то что вся логика подсчета в конструкторе немного сбивает с толку. Тут проблема в том, что мы когда создаем, не ожидаем, что там еще будет преобразование чего-то внутри, обычно это все выносится в методы по типу Sort(). Лучше сделать именно через метод. Допом к этому сделай еще выбор каким образом сортируем, через передачу компаратора в метод*
- [x] изменить название объектов в мейн
- [x] исправить сортировку (почему то не сортируется по алфавиту) 
- [x] в Reader есть методы которые семер не понимает зачем нужны
- [x] сделать буфер для считывания


## Описание работы програмы

Программа принимает в качестве аргумента имя текстового файла, и выводит CSV файл с колонками:
1. Слово.
2. Частота.
3. Частота (в %).
CSV файл должен быть упорядочен по убыванию частоты, то есть самые частые слова
должны идти в начале. Разделителями считать все символы кроме букв и цифр.

Аргументы командной строки программы:
> word_count.exe input.txt output.csv

## Структура lab0b 

класс Reader 

    поля:
    text - список слов
    конструктор:
    - открывает файл
    - если не открылся выдает исключение
    - считвает слова добавляет их в текст

    метод getText
    - возвращает text


класс Sorter

    поля:
    std::map<std::string, int> dict; 
    int wordCount = 0;
    std::multimap<int, std::string, std::greater<int>> sortedDict;
    конструктор:
    - приравнивает worldCount к размеру text
    - для каждого ключа (слова в text) прибавляю 1



класс CsvOutputer

## Изученные элементы языка

```cpp
std::string inputFile();
std::string outputFile();
```
Это я создаю объекты типа std::string потому что так реализован конструктор. То есть это эквивалентно 

```cpp
std::string inputFile = std::string();
std::string outputFile = std::string();
```
--- 

`isalnum(ch); `

эта функция проверяет, является ли символ буквой или цифрой.

---

`explicit` делает конструктор честным: он вызывается только тогда, когда ты сам его вызываешь, и никогда не будет вызван «сам собой» при конверсии типов.
Вообще его имеет смысл писать если в конструкторе только один параметр, 
потому что такие конструкторы потенциально позволяют неявные преобразования.
Типо пареметр это например какой нибудь класс, но даже передавая туда инт конструктор вызовется, от чего мы и избавляемся.

---

`std::ifstream file(this->fileName);`

Эта штука создает указатель типа "поток чтения из файла" и сразу инициализирует его открывая файл, что эквивалентно:

```cpp
std::ifstream file;
file.open("input.txt");
```

